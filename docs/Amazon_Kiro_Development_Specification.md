# Amazon Kiro AI Agent Framework 개발 스펙

## 1. 프로젝트 개요

### 1.1 목적
Amazon Kiro는 확장 가능한 AI 에이전트 프레임워크로, **[계획-실행]** 구조의 오케스트레이션을 통해 다양한 도메인 특화 에이전트를 개발할 수 있는 플랫폼입니다.

### 1.2 핵심 설계 철학
- **고정된 오케스트레이션**: 전체 흐름은 고정적으로 사용
- **5가지 튜닝 요소**: 도구, LLM 모델, 프롬프트, UI, LLM 기능을 통한 확장
- **우아한 확장**: if-else 조건 분기를 지양하고 우아한 확장 구조 추구
- **타입 투명성**: 외부에서 도구 호출 시 타입(내장/플러그인/MCP) 알 필요 없음

### 1.3 시스템 아키텍처
```
사용자 입력 → LLM Plan → 기능 실행 → LLM Plan → ... → 완료
```

## 2. 오케스트레이션 시스템

### 2.1 기본 구조
- **LLM 기능**: Plan, Chat, Tool Parameter Setting, Analyze, Summary, Visualize, User Response 등
- **TOOL 기능**: Built-In Tools, Plug-In Tools, MCP Tools

### 2.2 LLM Plan 기능 (핵심)
#### 기능 개요
- 사용자 입력을 받아 요구사항 분석 및 계획 수립
- 최초 계획 수립 → 단일(혹은 다수) 기능 수행 → 다음 스텝 결정 → 반복

#### 실행 특징
- 다양한 기능을 사용하는 것 가능
- 계획을 세우지 않고 즉시 사용자 응답도 가능
- 단순 응답: 계획 후 즉시 사용자 응답
- 복합 작업: 기능 수행 후 응답 전문 LLM을 통한 진행

#### 프롬프트 요구사항
- **필수 포함**: 모든 기능(LLM 및 TOOL)에 대한 설명(Description)
- **치환 요소**: 각 LLM 기능에 필요한 요소들이 유연하게 치환 가능

### 2.3 완료 조건
- LLM 종류 중 완료 기능(Chat, Response 등) 수행 시 완료 처리
- if-else 조건 분기보다는 우아한 방식으로 처리 (확장성 확보)

## 3. LLM 시스템

### 3.1 기본 원칙
- **역할 기반 분류**: 모든 LLM 기능은 역할 기반으로 분류
- **설정 기반 모델 선택**: 각 기능별로 모델 선택 가능
- **모델 특징 문서화**: 각 모델 특징을 분류하여 적합한 기능과 매핑

### 3.2 프롬프트 관리 체계
#### 관리 원칙
- **1:1 대응 관계**: 각 LLM 기능은 대응되는 프롬프트 보유
- **파일 기반 관리**: 별도 파일로 관리, 코드 수정 없이 수정 가능
- **캐싱 전략**: 파일 로드 기본, TTL 캐싱 전략 적용 가능

#### 프롬프트 구조
- **기본 골격**: 각 역할에 따라 차이가 있지만 유사하게 구성
- **기본 요소**: 시스템 정보(현재 시간 등), 역할 정보, 사용자 요청
- **추가 요소**: 기능에 따라 달라지는 항목들

#### 치환 요소 관리
- **변수 명 통일**: 프롬프트와 코드에서 동일한 변수 명 사용
- **사전 정의 요소**: 각 사전 정의된 요소(변수)에 정보 주입
- **유연한 구현**: 기본 string, string[] 등 다양한 타입 지원
- **응답 구조 정의**: LLM 응답 예시와 응답 구조 포함

### 3.3 응답 구조
#### 기본 응답 형태
- **JSON 구조**: 모든 응답은 JSON 구조 (각 기능 프롬프트 템플릿에 정의)
- **다음 스텝 결정**: 응답 결과를 기반으로 다음 스텝 진행 결정

#### 예외 응답 처리
- **사용자 응답**: JSON 응답하지 않고 사용자 응답만 생성
- **특수 기능**: Web 시각화 등 일부 요소는 JSON 외 응답 가능

### 3.4 LLM 기능(역할) 분류

#### 핵심 기능 (14가지)
1. **Planner / Orchestrator**: 사용자 요구 분석, 단계별 실행 계획 수립
2. **Interpreter / Analyzer**: 입력 텍스트 의미 분석, 핵심 정보 추출
3. **Summarizer**: 장문의 텍스트나 다수의 결과를 압축 요약
4. **Generator**: 새로운 텍스트, 코드, 시나리오 생성
5. **Evaluator / Critic**: 결과물의 품질 평가, 개선 포인트 피드백
6. **Rewriter / Refiner**: 기존 결과물을 개선, 특정 목적에 맞게 재작성
7. **Explainer / Tutor**: 특정 개념, 프로세스, 코드에 대해 단계별 설명
8. **Reasoner / Inference Engine**: 규칙/조건 기반 추론, 논리적 일관성 점검
9. **Converter / Translator**: 언어 번역, 포맷 변환, 코드 변환
10. **Visualizer (Text-based)**: 데이터/프로세스를 도표, 표, 그래프 형태로 설명
11. **Tool Parameter Setter**: 외부 TOOL 호출에 필요한 파라미터 값 구성
12. **Dialogue Manager**: 사용자와 대화 흐름 관리, 맥락 기억
13. **Knowledge Retriever**: 외부 벡터DB, 문서 검색 API에서 정보 조회
14. **Meta-Manager**: 현재 LLM 응답의 신뢰도 추정, 역할 호출 결정

## 4. TOOL 시스템

### 4.1 TOOL 정의
**Tool = Function + Metadata + Contract**
- **Function**: 실제 수행하는 작업
- **Metadata**: 자기 설명 (이름, 설명, 버전)
- **Contract**: 입출력 스키마

### 4.2 3가지 TOOL 구성 방식

#### 4.2.1 Built-In Tools
- **정의**: 시스템 필수 기능, 성능과 신뢰성이 필요한 기능
- **포함 대상**: 임베딩 캐싱, Vector DB(RAG), 기타 시스템 핵심 기능
- **제외 대상**: 메모리 관리, 로깅, 모니터링 등 (프로젝트 구성요소로 분류)

#### 4.2.2 Plug-In Tools
- **정의**: 도메인 특화 기능, 사용자 커스텀 기능, 에이전트의 성격을 결정하는 도구
- **기술적 구현**: 메타 프로그래밍 (DLL, Reflection, Attribute), Manifest 파일 기반
- **독립적 운영**: 메인 프로젝트와 독립적으로 관리, 운영, 배포

#### 4.2.3 MCP Tools
- **정의**: 표준화된 확장 방식을 제공하는 유연한 도구
- **기술적 요구사항**: MCP(Model Context Protocol) 표준 준수, 인터페이스 추상화

### 4.3 공통 요구사항
- **유일한 이름**: 모든 Tool은 LLM이 호출할 수 있는 유일한 이름 보유
- **자기 설명**: 자신을 설명할 수 있는 Description 필수
- **동일한 인터페이스**: 모든 Tool은 동일한 구조의 실행 인터페이스 보유
- **유연한 구조**: 입출력 구조는 유연하게 정의

### 4.4 설계 원칙
- **Tool 간 비참조**: Tool간 상호 참조 금지, LLM 오케스트레이션을 통해서만 호출
- **LLM 전용**: LLM이 사용하지 않는 기능은 Tool로 정의하지 않음
- **Registry 방식**: 전체 도구 리스트는 동등한 구조로 관리, LLM 프롬프트에 제공

### 4.5 Tool Registry 시스템
```
Tool Registry
├── Built-In Tools
│   ├── Tool Name: Description, Contract
│   └── ...
├── Plug-In Tools
│   ├── Tool Name: Description, Contract
│   └── ...
└── MCP Tools
    ├── Tool Name: Description, Contract
    └── ...
```

## 5. 확장성 시스템

### 5.1 5가지 튜닝 요소

#### 5.1.1 도구(Tools) 확장
- **플러그인 기반**: Plug-In Tools를 통한 도메인 특화 기능 추가
- **MCP 기반**: 표준 프로토콜을 통한 유연한 확장
- **Built-In 확장**: 시스템 핵심 기능의 점진적 확장

#### 5.1.2 LLM 모델 전환
- **옵션 기반**: 설정(Config)으로 모델 선택
- **기능별 최적화**: 각 LLM 기능별로 적합한 모델 매핑
- **지원 모델**: GPT 시리즈, Claude 시리즈, Local LLM, 기타 API 호환 모델

#### 5.1.3 프롬프트 관리
- **설정 파일 기반**: 코드 수정 없이 프롬프트 수정 가능
- **치환 시스템**: 동적 요소 주입을 통한 유연한 프롬프트 구성
- **TTL 캐싱**: 성능 최적화를 위한 캐싱 전략

#### 5.1.4 사용자 인터페이스 다양화
- **Web Interface**: 웹 기반 사용자 인터페이스
- **Console Interface**: 명령줄 기반 인터페이스
- **Application Interface**: 데스크톱/모바일 애플리케이션
- **API Interface**: RESTful API 또는 기타 프로그래밍 인터페이스

#### 5.1.5 LLM 기능 확장
- **사전 정의**: 기본적으로 14가지 역할로 사전 정의
- **확장 용이성**: 새로운 역할 추가가 어렵지 않도록 설계
- **플러그인 방식**: LLM 기능도 플러그인 방식으로 확장 가능

### 5.2 확장성 구현 전략

#### 메타 프로그래밍 활용
- **Reflection**: 런타임 타입 정보 활용
- **Attribute**: 메타데이터 기반 자동 등록
- **Dynamic Loading**: DLL 기반 동적 로딩

#### 인터페이스 기반 설계
```csharp
// 예시 구조
public interface ITool
{
    string Name { get; }
    string Description { get; }
    IToolContract Contract { get; }
    Task<IToolResult> ExecuteAsync(IToolInput input);
}

public interface ILLMFunction
{
    string Role { get; }
    string Description { get; }
    Task<ILLMResult> ExecuteAsync(ILLMContext context);
}
```

#### Registry 패턴
- **중앙 집중식 관리**: 모든 확장 요소의 중앙 등록소
- **동적 발견**: 자동 발견 및 등록 메커니즘
- **메타데이터 관리**: 각 요소의 메타데이터 중앙 관리

## 6. 기술적 고려사항

### 6.1 실행 방식
- **병렬 실행 가능**: Tool은 기술적으로 병렬 실행 가능
- **순차 진행**: LLM이 bottleneck이므로 순차 진행으로 충분

### 6.2 이력 관리
- **실행 결과 이력**: Tool 실행 결과는 지속적인 이력 관리 필요
- **디버깅 및 분석**: 문제 해결 및 성능 분석을 위한 데이터 확보

### 6.3 캐싱 전략
- **개별 책임**: Tool의 캐싱은 각 Tool의 구현부에서 책임
- **합리적 운영**: Tool별 특성에 맞는 캐싱 전략 적용 가능

### 6.4 품질 관리
- **Contract 검증**: 입출력 스키마 검증
- **오류 처리**: Tool 실행 오류에 대한 표준 처리
- **모니터링**: Tool 성능 및 안정성 모니터링

## 7. 확장 시나리오

### 7.1 도메인 특화 에이전트
- **금융 에이전트**: 금융 데이터 처리 도구 + 금융 특화 프롬프트
- **의료 에이전트**: 의료 정보 검색 도구 + 의료 전문 모델
- **개발 에이전트**: 코드 분석 도구 + 개발 특화 LLM 기능

### 7.2 인터페이스 특화
- **챗봇 에이전트**: 대화형 웹 인터페이스 + 대화 관리 LLM 특화
- **API 에이전트**: RESTful API + 구조화된 응답 특화
- **배치 에이전트**: 콘솔 인터페이스 + 대량 처리 최적화

### 7.3 성능 최적화
- **로컬 모델 에이전트**: 로컬 LLM + 경량화 프롬프트
- **클라우드 에이전트**: 클라우드 LLM + 고성능 프롬프트
- **하이브리드 에이전트**: 기능별 모델 분산 + 최적화된 라우팅

## 8. 개발 로드맵

### 8.1 Phase 1: 기본 확장성
- 플러그인 도구 지원
- 설정 기반 모델 전환
- 기본 프롬프트 관리

### 8.2 Phase 2: 고급 확장성
- MCP 도구 지원
- LLM 기능 플러그인화
- 다중 인터페이스 지원

### 8.3 Phase 3: 생태계 구축
- 확장 요소 마켓플레이스
- 커뮤니티 도구 통합
- 자동화된 확장 배포

## 9. 결론

Amazon Kiro AI Agent Framework는 **하나의 기본 구조로 다양한 특화된 에이전트를 효율적으로 개발**할 수 있는 확장 가능한 플랫폼입니다. 고정된 오케스트레이션 구조와 5가지 튜닝 요소를 통해 우아한 확장성을 제공하며, 표준화된 인터페이스와 Registry 패턴을 통해 일관된 개발 경험을 보장합니다.