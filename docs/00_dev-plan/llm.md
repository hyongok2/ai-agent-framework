## LLM 운영 방안

0. 개요
    - 모든 LLM 기능은 역할 기반으로 분류됨. (이 역할 기반의 분류가 중요함.)
    - 각 기능은 설정 기반으로 모델을 선택할 수 있도록 함. 
    - 이를 위해서는 각 모델에 대한 특징을 분류해서 적합한 기능들과 맵핑해서 문서화 해야 함.

1. LLM 호출 프롬프트 운영
    - 각 LLM의 기능은 그에 대응되는 프롬프트를 가진다. 1:1 대응 관계.
    - 프롬프트는 별도 파일로 관리되며, 코드 수정 없이 수정 가능해야 한다.(파일 로드가 기본이지만, TTL 캐싱 전략을 쓸 수도 있다.)
    - 프롬프트의 구조는 각 역할에 따라 차이가 있지만, 기본 골격은 유사하게 구성한다.
    - 기본 요소는 시스템 정보(현재 시간 등), 역할 정보, 사용자 요청 등이 있으며, 다른 요소는 기능에 따라 항목은 달라진다.
    - 프롬프트의 설계도 코드의 설계만큼 중요하다. 기능에 따라 좋은 전략을 수립해야 한다.
    - 기본적으로 프롬프트와 코드는 상호 의존성이 거의 없어야 한다.(파일 이름은 고정되야 할 것이지만.)
    - 다만 코드에서 주입해야 하는 정보는 프롬프트가 치환되도록 구성해야 한다.
    - 이 치환 해야 하는 정보의 관리가 중요한데, 이것을 유연하게 설계하는 전략에 대한 고민이 필요하다.
    - 치환해야 하는 요소의 명칭(변수 명?)은 프롬프트와 코드가 동일하게 관리하여야 할 것이다.
    - 코드에서는 각 사전 정의된 요소(변수)에 정보를 주입한다. 그 모든 사전 정의 정보를 프롬프트 생성 시 치환하게 된다.
    - 이 부분이 가능하면 유연하게 구현되어야 한다. 기본적으로 변수 하나는 string이겟지만, string[]인 경우도 있을 것이다.
    - 프롬프트에는 LLM 응답의 예시와 응답 구조가 정의되어야 한다.

2. LLM 호출 응답 구조
    - LLM은 프롬프트에 정의된 응답 구조를 기반으로 응답하도록 구성한다.
    - 그 결과를 기반으로 다음 스텝의 진행을 결정하게 된다.
    - 기본적으로 모든 응답은 json 구조를 가지며, 이것은 각 기능의 프롬프트 템플릿에 정의한다.
    - json으로 출력의 정의와 코드는 또 상관 관계(의존 관계)를 가질 수 밖에 없다.
    - 이것 또한 프롬프트 치환 요소와 유사하게, 어떻게 하면 유연하고 우아하게 구현할 수 있을지 고민이 필요한 부분이다.
    - 가능하면 응답 구조를 표준화할 수 있어야 우아하게 구현할 수 있을 것이다.
    - 이 경우 프롬프트 구조에 대한 규칙이 사전에 정의되어 강제화가 필요한 부분이 있을 것이다.(어쩔 수 없는 제약)
    - 위에 언급한 것처럼 모든 응답은 Json이지만, 특별히 사용자 응답을 생성하는 기능의 경우는 Json 응답을 하지 않고, 사용자 응답만 생성한다.
    - 그외에도 일부 요소들은 Json 응답을 하지 않을 수 있으며, 이것들에 대한 정의는 별도로 한다. 예를 들면 Web 시각화 같은 기능들..
    - 응답에 대한 파싱은 어쩔 수 없이 타입 별로 상이할 수 밖에 없다.
    - 이런 모든 것들이 조건문으로 처리되지 않고, 우아하게 구현될 수 있어야 한다.
    - 가능하면 기능들이 공통 요소를 상속한 개별 클래스로 구현되는 방안이 좋을 것이다.
    - 응답 파싱이 실패하는 경우에 대한 전략도 기능에 따라 상이하게 수립될 필요가 있을 것이다.
    
3. LLM의 기능(역할) 분류
    - 아래 정리 내용 참고

4. 추가 - 임베딩 캐싱 전략
    - 의미적으로 유사한 요청 감지
    - 결과 재사용 가능성 판단
    - TTL과 무효화 전략

5. 추가 - 스트리밍 응답
    - 초기 개발은 일반 응답으로 처리하는 것으로 개발함.
    - 스트리밍 응답은 추후 검토 필요함.

6. Fallback 전략 수립
    - LLM 응답이 실패한 경우에 대한 전략 수립 필요.

7. 확장성
    - LLM 기능을 추가하는 것은 TOOL만큼 유연하지 않지만, 확장이 가능하도록 초기부터 구현에 신경을 써야 함.

---

## LLM 기능(역할) 분류 안

### 1. **Planner / Orchestrator**

* 사용자 요구 분석, 단계별 실행 계획 수립
* 작업 순서, 조건 분기, 도구 매핑 결정
* 실행 중 오류나 변경 발생 시 재계획

---

### 2. **Interpreter / Analyzer**

* 입력 텍스트(자연어, 코드, 로그, 문서 등) 의미 분석
* 핵심 정보 추출, 분류, 요약
* 모호성 해석 및 의도 재정의

---

### 3. **Summarizer**

* 장문의 텍스트나 다수의 결과를 압축 요약
* 요약 목적에 따라 다양한 스타일 제공 (간단 개요 / 실행 보고 / 기술 문서 요약 등)

---

### 4. **Generator**

* 새로운 텍스트, 코드, 시나리오 생성
* 자연어 응답 / 코드 샘플 / 보고서 / 시뮬레이션 데이터 생성
* 주어진 규칙/포맷(JSON, Markdown 등)에 맞춰 출력

---

### 5. **Evaluator / Critic**

* 결과물의 품질 평가 (정확성, 일관성, 스타일, 포맷 적합성)
* 대안 제시, 개선 포인트 피드백
* Self-Check, Chain-of-Thought 기반 평가

---

### 6. **Rewriter / Refiner**

* 기존 결과물을 개선 (간결화, 가독성 향상, 문체 통일, 오류 수정)
* 특정 목적에 맞게 재작성 (보고용, 기술 문서용, 사용자 친화용 등)

---

### 7. **Explainer / Tutor**

* 특정 개념, 프로세스, 코드에 대해 단계별 설명
* 초보자/전문가 수준 맞춤형 설명
* Q\&A 형식으로 학습 지원

---

### 8. **Reasoner / Inference Engine**

* 규칙/조건 기반 추론 (If-Then, 시나리오별 결과 예측)
* 불완전한 정보로부터 합리적 추론
* 논리적 일관성 점검

---

### 9. **Converter / Translator**

* 언어 번역 (다국어 자연어 변환)
* 포맷 변환 (평문 ↔ JSON ↔ Markdown 등)
* 코드 변환 (Python ↔ C#, SQL ↔ LINQ 등)

---

### 10. **Visualizer (Text-based)**

* 데이터/프로세스를 도표, 표, 그래프 형태로 설명
* PlantUML, Mermaid, Markdown 표 생성
* 차트, 시퀀스 다이어그램, 구조도 텍스트 기반 생성

---

### 11. **Tool Parameter Setter**

* 외부 TOOL 호출에 필요한 파라미터 값 구성
* 입력값 보정, 기본값 채우기, 누락 항목 유추
* JSON Schema, OpenAPI, Manifest 기반 파라미터 자동 매핑

---

### 12. **Dialogue Manager**

* 사용자와 대화 흐름 관리
* 맥락 기억, 대화 단계 조정
* Clarification Question 생성 (필요한 추가 정보 요청)

---

### 13. **Knowledge Retriever**

* 외부 벡터DB, 문서 검색 API, 사내 데이터베이스에서 정보 조회
* 쿼리 재구성, 관련도 높은 결과 정리
* 검색 결과를 다음 Reasoning 단계로 전달

---

### 14. **Meta-Manager**

* 현재 LLM 응답의 신뢰도 추정 (확실 / 불확실)
* 어떤 역할(Planner, Generator, Evaluator 등)을 호출할지 결정
* 자기 출력에 대한 메타 분석(Self-Reflection)

