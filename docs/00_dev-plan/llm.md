# LLM 시스템

## 개요

### 기본 원칙
- **역할 기반 분류**: 모든 LLM 기능은 역할 기반으로 분류 (핵심)
- **설정 기반 모델 선택**: 각 기능별로 모델 선택 가능
- **모델 특징 문서화**: 각 모델 특징을 분류하여 적합한 기능과 매핑

## LLM 호출 프롬프트 운영

### 프롬프트 관리 체계
- **1:1 대응 관계**: 각 LLM 기능은 대응되는 프롬프트 보유
- **파일 기반 관리**: 별도 파일로 관리, 코드 수정 없이 수정 가능
- **캐싱 전략**: 파일 로드 기본, TTL 캐싱 전략 적용 가능

### 프롬프트 구조
- **기본 골격**: 각 역할에 따라 차이가 있지만 유사하게 구성
- **기본 요소**: 시스템 정보(현재 시간 등), 역할 정보, 사용자 요청
- **추가 요소**: 기능에 따라 달라지는 항목들

### 설계 원칙
- **상호 의존성 최소화**: 프롬프트와 코드의 의존성 거의 없어야 함
- **파일 이름 고정**: 기본적으로 파일 이름은 고정
- **치환 시스템**: 코드에서 주입하는 정보를 프롬프트에서 치환

### 치환 요소 관리
- **변수 명 통일**: 프롬프트와 코드에서 동일한 변수 명 사용
- **사전 정의 요소**: 각 사전 정의된 요소(변수)에 정보 주입
- **유연한 구현**: 기본 string, string[] 등 다양한 타입 지원
- **응답 구조 정의**: LLM 응답 예시와 응답 구조 포함

## LLM 호출 응답 구조

### 기본 응답 형태
- **JSON 구조**: 모든 응답은 JSON 구조 (각 기능 프롬프트 템플릿에 정의)
- **다음 스텝 결정**: 응답 결과를 기반으로 다음 스텝 진행 결정

### 응답 구조 표준화
- **표준화 필요성**: 응답 구조 표준화로 우아한 구현 가능
- **프롬프트 규칙**: 프롬프트 구조 규칙 사전 정의 및 강제화
- **JSON 의존성**: JSON 출력 정의와 코드는 상호 의존 관계

### 예외 응답 처리
- **사용자 응답**: JSON 응답하지 않고 사용자 응답만 생성
- **특수 기능**: Web 시각화 등 일부 요소는 JSON 외 응답 가능
- **별도 정의**: 예외 응답들에 대한 별도 정의 필요

### 응답 파싱 전략
- **타입별 파싱**: 응답 파싱은 타입별로 상이
- **우아한 구현**: 조건문 처리가 아닌 우아한 구현 필요
- **클래스 구조**: 공통 요소 상속한 개별 클래스 구현
- **파싱 실패 대응**: 기능별 상이한 파싱 실패 전략 수립

## LLM 기능(역할) 분류

AI Agent Framework의 LLM 기능을 4가지 카테고리, 총 14개 역할로 분류합니다.

### 핵심 오케스트레이션 (2개)

#### 1. Planner
- **목적**: 계획 수립 및 조율
- **기능**: 사용자 요구 분석, 단계별 실행 계획 수립, 작업 순서/조건 분기/도구 매핑 결정
- **구현 상태**: ✅ TaskPlannerFunction, ToolSelectorFunction

#### 2. ToolParameterSetter
- **목적**: Tool 파라미터 생성
- **기능**: 외부 Tool 호출에 필요한 파라미터 값 구성, 입력값 보정, 기본값 채우기, 누락 항목 유추
- **특징**: JSON Schema, OpenAPI 기반 파라미터 자동 매핑, Just-In-Time 파라미터 생성
- **구현 상태**: ✅ ParameterGeneratorFunction

### 데이터 처리 (4개)

#### 3. Summarizer
- **목적**: 내용 요약
- **기능**: 장문의 텍스트나 다수의 결과를 압축 요약
- **특징**: 요약 목적에 따라 다양한 스타일 제공 (간단 개요 / 실행 보고 / 기술 문서 요약 등)
- **구현 상태**: ⏳ 예정

#### 4. Converter
- **목적**: 변환 및 번역
- **기능**: 언어 번역, 포맷 변환, 코드 변환
- **예시**: 다국어 자연어 변환, JSON ↔ Markdown, Python ↔ C#, SQL ↔ LINQ
- **구현 상태**: ⏳ 예정

#### 5. Generator
- **목적**: 콘텐츠 생성
- **기능**: 새로운 텍스트, 코드, 보고서, 시나리오 생성
- **특징**: 주어진 규칙/포맷(JSON, Markdown 등)에 맞춰 출력
- **구현 상태**: ⏳ 예정

#### 6. Extractor
- **목적**: 정보 추출
- **기능**: 텍스트에서 특정 정보 추출 (엔티티, 날짜, 이메일, 전화번호, 키워드 등)
- **특징**: 구조화되지 않은 데이터에서 구조화된 정보 추출
- **구현 상태**: ⏳ 예정

### 분석 및 검증 (4개)

#### 7. Analyzer
- **목적**: 입력 분석 및 해석
- **기능**: 입력 텍스트(자연어, 코드, 로그, 문서 등) 의미 분석
- **특징**: 핵심 정보 추출, 모호성 해석 및 의도 재정의
- **구현 상태**: ⏳ 예정

#### 8. Classifier
- **목적**: 분류 및 카테고리화
- **기능**: 감정 분석, 스팸 분류, 주제 분류, 우선순위 분류 등
- **특징**: 다중 레이블 분류, 계층적 분류 지원
- **구현 상태**: ⏳ 예정

#### 9. Evaluator
- **목적**: 품질 평가 및 비평
- **기능**: 결과물의 품질 평가 (정확성, 일관성, 스타일, 포맷 적합성)
- **특징**: 대안 제시, 개선 포인트 피드백, Self-Check, Chain-of-Thought 기반 평가
- **구현 상태**: ⏳ 예정

#### 10. Validator
- **목적**: 데이터 검증
- **기능**: 스키마 검증, 형식 확인, 규칙 준수 여부 검사
- **특징**: Evaluator(품질 평가)와 달리 형식/규칙 검증에 집중
- **구현 상태**: ⏳ 예정

### 추론 및 개선 (3개)

#### 11. Reasoner
- **목적**: 추론 및 논리 검증
- **기능**: 규칙/조건 기반 추론, 불완전한 정보로부터 합리적 추론
- **특징**: If-Then 추론, 시나리오별 결과 예측, 논리적 일관성 점검
- **구현 상태**: ⏳ 예정

#### 12. Refiner
- **목적**: 개선 및 재작성
- **기능**: 기존 결과물을 개선 (간결화, 가독성 향상, 문체 통일, 오류 수정)
- **특징**: 특정 목적에 맞게 재작성 (보고용, 기술 문서용, 사용자 친화용 등)
- **구현 상태**: ⏳ 예정

#### 13. Explainer
- **목적**: 설명 및 교육
- **기능**: 특정 개념, 프로세스, 코드에 대해 단계별 설명
- **특징**: 초보자/전문가 수준 맞춤형 설명, Q&A 형식 학습 지원
- **구현 상태**: ⏳ 예정

### 제거된 역할 (AI Agent Framework 목적에 부합하지 않음)

- **Visualizer**: LLM의 시각화 능력 제한적 (Mermaid, PlantUML은 Generator에서 처리)
- **DialogueManager**: AI Agent는 대화형 챗봇이 아닌 작업 실행 프레임워크
- **KnowledgeRetriever**: Tool(WebSearch, VectorDB)로 대체
- **MetaManager**: 너무 추상적이고 실제 구현 사례 불명확

## 추가 고려사항

### 임베딩 캐싱 전략
- 의미적으로 유사한 요청 감지
- 결과 재사용 가능성 판단
- TTL과 무효화 전략

### 스트리밍 응답
- 스트리밍 응답을 통해 사용자 경험 개선!

### Fallback 전략
- LLM 응답 실패 시 대응 전략 수립 필요

### 확장성
- LLM 기능 추가는 TOOL만큼 유연하지 않지만 확장 가능하도록 초기부터 설계