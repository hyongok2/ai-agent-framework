# LLM 시스템 컨셉 기획서

## 1. 시스템 컨셉

### 1.1 핵심 아이디어
**"LLM은 오케스트레이션의 두뇌"**
- LLM은 단순한 텍스트 생성기가 아닌, Agent의 **인지 엔진**
- 각 LLM 호출은 명확한 **인지적 목적**을 가짐
- 모든 LLM 기능은 **역할 기반**으로 분류되고 특화됨

### 1.2 설계 철학
- **Purpose-Driven**: 각 호출은 명확한 목적(CallType)을 가짐
- **Model-Agnostic**: 실제 모델은 설정으로 관리, 코드는 모델을 모름
- **Structured by Default**: 구조화된 응답이 기본, 자유 텍스트는 예외
- **Streaming Native**: 모든 응답은 청크 단위로 흐름

## 2. LLM의 역할 체계

### 2.1 역할 분류 (20가지)

#### **계획/전략 영역**
1. **Planner** (계획자)
   - 실행 계획 수립, 단계별 작업 순서 결정
   
2. **Strategist** (전략가)
   - 장기 전략 수립, 목표 달성 경로 설계
   
3. **Orchestrator** (조율자)
   - 여러 작업/도구 간 조율, 의존성 관리

#### **분석/이해 영역**
4. **Analyzer** (분석가)
   - 데이터 분석, 패턴 발견, 인사이트 도출
   
5. **Interpreter** (해석자)
   - 복잡한 정보 해석, 의미 파악, 맥락 이해
   
6. **Diagnostician** (진단자)
   - 문제 원인 파악, 오류 분석, 상태 진단

#### **변환/생성 영역**
7. **Transformer** (변환자)
   - 형식 변환, 데이터 구조 변경
   
8. **Generator** (생성자)
   - 콘텐츠 생성, 창의적 작성
   
9. **Translator** (번역자)
   - 언어 번역, 도메인 간 용어 변환
   
10. **Formatter** (포맷터)
    - 출력 형식 정리, 스타일 적용

#### **추출/정리 영역**
11. **Extractor** (추출자)
    - 핵심 정보 추출, 구조화된 데이터 수집
    
12. **Summarizer** (요약자)
    - 긴 내용 요약, 핵심 포인트 정리
    
13. **Organizer** (정리자)
    - 정보 분류, 체계화, 구조화

#### **평가/판단 영역**
14. **Evaluator** (평가자)
    - 품질 평가, 성능 측정, 결과 검증
    
15. **Validator** (검증자)
    - 데이터 유효성 검증, 규칙 준수 확인
    
16. **Judge** (판단자)
    - 의사결정, 선택, 우선순위 결정

#### **상호작용 영역**
17. **Conversationalist** (대화자)
    - 자연스러운 대화, 컨텍스트 유지
    
18. **Explainer** (설명자)
    - 복잡한 개념 설명, 이유 설명, 교육
    
19. **Advisor** (조언자)
    - 추천, 제안, 가이드 제공

20. **Responder** (최종 응답자)
    - 사용자에게 전달할 최종 응답 생성
    - 모든 처리 결과를 종합한 자연어 응답
    - **오케스트레이션 완료 신호**

#### **특수 기능 영역**
21. **ParameterSetter** (파라미터 설정자)
    - Tool 파라미터 생성, API 호출 구성

#### **시각화 영역**
22. **Visualizer** (시각화 생성자)
    - 데이터 시각화 웹 페이지 생성, 차트/그래프 코드 생성
    - HTML/CSS/JS를 활용한 인터랙티브 대시보드 구성

### 2.2 역할별 특성과 요구사항

| 역할 그룹 | 핵심 능력 | 모델 요구사항 | 응답 특성 |
|---------|----------|------------|----------|
| **계획/전략** | 추론, 순서화 | 높은 지능 | 구조화, 정확성 |
| **분석/이해** | 패턴 인식 | 컨텍스트 이해 | 인사이트 제공 |
| **변환/생성** | 일관성 | 창의성+정확성 | 형식 준수 |
| **추출/정리** | 선별 능력 | 요약 능력 | 간결성 |
| **평가/판단** | 객관성 | 일관된 기준 | 명확한 판단 |
| **상호작용** | 공감, 자연스러움 | 빠른 응답 | 친근함 |
| **특수 기능** | 도메인 지식 | 정확성 | 구조화 |
| **시각화** | 코드 생성 능력 | 웹 기술 이해 | 실행 가능 코드 |

### 2.3 역할 매핑 예시

```yaml
사용 사례 → 역할 선택:
  "이 데이터를 분석해줘" → Analyzer
  "다음 단계는 뭐야?" → Planner
  "이게 맞는지 확인해줘" → Validator
  "쉽게 설명해줘" → Explainer
  "JSON으로 바꿔줘" → Transformer
  "핵심만 뽑아줘" → Extractor
  "어떻게 생각해?" → Advisor
  "이 도구 실행해줘" → ParameterSetter
  "차트로 보여줘" → Visualizer
  "결과를 알려줘" → Responder (최종)
```

## 3. CallType 시스템

### 3.1 CallType의 의미
- CallType은 **20가지 역할을 기술적으로 구현**한 것
- 각 역할은 하나 이상의 CallType으로 매핑됨
- CallType은 프롬프트 전략, 모델 선택, 응답 처리를 결정

### 3.2 역할-CallType 매핑
```
역할 → CallType → 실행:
  Planner → Plan → 계획 JSON 생성
  Analyzer → Analyze → 분석 결과 구조화
  Generator → Generate → 콘텐츠 생성
  Validator → Validate → 검증 결과 반환
  Conversationalist → Chat → 대화 진행
  Responder → UserResponse → 최종 응답 (완료)
  Visualizer → Visualize → HTML/JS 코드 생성
```

### 3.3 특별한 역할: Responder
```yaml
Responder (UserResponse) 특성:
  목적: 오케스트레이션 최종 완료
  특징:
    - 모든 실행 결과를 종합
    - 구조화되지 않은 자연어 응답
    - 사용자 친화적인 최종 메시지
    - 실행 시 오케스트레이션 종료
  
  다른 역할과의 차이:
    - Conversationalist: 대화 계속
    - Responder: 대화 종료 및 최종 전달
```

### 3.4 CallType 결정 흐름
```
사용자 요청 → 의도 파악 → 역할 식별 → 
CallType 매핑 → 모델 선택 → 프롬프트 생성 → 
실행 → 응답 처리 → 구조화/검증
```

### 3.5 Visualizer 역할 특별 고려사항
```yaml
Visualizer 특성:
  입력: 데이터 + 시각화 요구사항
  처리: 
    - 데이터 분석 및 적절한 차트 타입 선택
    - Chart.js, D3.js, Plotly 등 라이브러리 활용
    - 반응형 및 인터랙티브 요소 포함
  출력: 
    - 완전한 HTML/CSS/JavaScript 코드
    - 독립 실행 가능한 웹 페이지
    - 또는 React/Vue 컴포넌트
```

## 4. 프롬프트 엔지니어링 시스템

### 4.1 템플릿 기반 접근
- 프롬프트는 **코드가 아닌 자산(Asset)**
- 버전 관리와 A/B 테스트 가능
- 도메인 전문가가 코드 없이 개선 가능

### 4.2 계층적 프롬프트 구조
```
System Prompt (역할과 제약)
  ├─ Context (상황과 배경)
  ├─ Instructions (구체적 지시)
  ├─ Examples (Few-shot)
  └─ Output Format (응답 형식)
```

### 4.3 동적 프롬프트 생성
- 컨텍스트에 따라 프롬프트 요소 동적 조합
- 토큰 제한에 따른 자동 압축
- 중요도에 따른 정보 우선순위

## 5. 모델 추상화 전략

### 5.1 Model Profile 컨셉
- 모델을 직접 지정하지 않고 **용도(Profile)**로 지정
- Profile 예시: `fast`, `accurate`, `creative`, `local`
- 환경과 상황에 따라 실제 모델은 동적 결정

### 5.2 Capability 기반 라우팅
```
요구 Capability → 가능한 모델 필터링 → 
Profile 매칭 → 비용/성능 최적화 → 최종 선택
```

### 5.3 폴백 전략
- Primary 실패 시 자동으로 Secondary 모델로
- Capability 부족 시 다른 CallType으로 변환
- 최악의 경우 사용자에게 제한 사항 안내

## 6. 구조화된 출력 보장

### 6.1 Schema-First 접근
- 먼저 원하는 출력 구조를 정의
- LLM은 이 구조를 채우는 역할
- 검증 실패 시 자동 수정 시도

### 6.2 점진적 구조화
```
1단계: 자유 텍스트 생성
2단계: 핵심 정보 추출
3단계: 구조화된 형식으로 변환
4단계: Schema 검증 및 수정
```

## 7. 스트리밍 아키텍처

### 7.1 왜 스트리밍인가?
- 긴 응답에서도 즉각적인 피드백
- 중간 취소 가능
- 메모리 효율적
- 실시간 UI 업데이트

### 7.2 청크 타입과 의미
- **Token**: 실시간 텍스트 스트림
- **Partial**: 점진적 JSON 구축
- **Status**: 진행 상황 알림
- **Final**: 완성된 결과

## 8. 비용과 성능 최적화

### 8.1 지능적 캐싱
- 의미적으로 유사한 요청 감지
- 결과 재사용 가능성 판단
- TTL과 무효화 전략

### 8.2 토큰 경제
- 필요한 만큼만 생성
- 조기 종료 조건
- 압축과 요약을 통한 컨텍스트 관리

## 9. 오케스트레이션과의 관계

### 9.1 LLM as Decision Maker
- Plan CallType은 오케스트레이션의 핵심
- 다음 단계를 결정하는 두뇌 역할
- 실행 결과를 평가하고 재계획

### 9.2 LLM as Executor
- 특정 인지적 작업 수행
- Tool과 함께 Step의 실행 주체
- 결과는 다시 Plan으로 피드백

## 10. 확장성과 진화

### 10.1 새로운 CallType 추가
- 새로운 사용 패턴 발견 시 CallType 추가
- 기존 시스템 변경 없이 확장 가능
- 플러그인 방식으로 CallType Handler 추가

### 10.2 멀티모달 확장
- Vision, Audio는 새로운 CallType으로
- 동일한 추상화 유지
- Provider별 지원 여부만 체크