# LLM 시스템

## 개요

### 기본 원칙
- **역할 기반 분류**: 모든 LLM 기능은 역할 기반으로 분류 (핵심)
- **설정 기반 모델 선택**: 각 기능별로 모델 선택 가능
- **모델 특징 문서화**: 각 모델 특징을 분류하여 적합한 기능과 매핑

## LLM 호출 프롬프트 운영

### 프롬프트 관리 체계
- **1:1 대응 관계**: 각 LLM 기능은 대응되는 프롬프트 보유
- **파일 기반 관리**: 별도 파일로 관리, 코드 수정 없이 수정 가능
- **캐싱 전략**: 파일 로드 기본, TTL 캐싱 전략 적용 가능

### 프롬프트 구조
- **기본 골격**: 각 역할에 따라 차이가 있지만 유사하게 구성
- **기본 요소**: 시스템 정보(현재 시간 등), 역할 정보, 사용자 요청
- **추가 요소**: 기능에 따라 달라지는 항목들

### 설계 원칙
- **상호 의존성 최소화**: 프롬프트와 코드의 의존성 거의 없어야 함
- **파일 이름 고정**: 기본적으로 파일 이름은 고정
- **치환 시스템**: 코드에서 주입하는 정보를 프롬프트에서 치환

### 치환 요소 관리
- **변수 명 통일**: 프롬프트와 코드에서 동일한 변수 명 사용
- **사전 정의 요소**: 각 사전 정의된 요소(변수)에 정보 주입
- **유연한 구현**: 기본 string, string[] 등 다양한 타입 지원
- **응답 구조 정의**: LLM 응답 예시와 응답 구조 포함

## LLM 호출 응답 구조

### 기본 응답 형태
- **JSON 구조**: 모든 응답은 JSON 구조 (각 기능 프롬프트 템플릿에 정의)
- **다음 스텝 결정**: 응답 결과를 기반으로 다음 스텝 진행 결정

### 응답 구조 표준화
- **표준화 필요성**: 응답 구조 표준화로 우아한 구현 가능
- **프롬프트 규칙**: 프롬프트 구조 규칙 사전 정의 및 강제화
- **JSON 의존성**: JSON 출력 정의와 코드는 상호 의존 관계

### 예외 응답 처리
- **사용자 응답**: JSON 응답하지 않고 사용자 응답만 생성
- **특수 기능**: Web 시각화 등 일부 요소는 JSON 외 응답 가능
- **별도 정의**: 예외 응답들에 대한 별도 정의 필요

### 응답 파싱 전략
- **타입별 파싱**: 응답 파싱은 타입별로 상이
- **우아한 구현**: 조건문 처리가 아닌 우아한 구현 필요
- **클래스 구조**: 공통 요소 상속한 개별 클래스 구현
- **파싱 실패 대응**: 기능별 상이한 파싱 실패 전략 수립

## LLM 기능(역할) 분류

### 1. Planner / Orchestrator
- 사용자 요구 분석, 단계별 실행 계획 수립
- 작업 순서, 조건 분기, 도구 매핑 결정
- 실행 중 오류나 변경 발생 시 재계획

### 2. Interpreter / Analyzer
- 입력 텍스트(자연어, 코드, 로그, 문서 등) 의미 분석
- 핵심 정보 추출, 분류, 요약
- 모호성 해석 및 의도 재정의

### 3. Summarizer
- 장문의 텍스트나 다수의 결과를 압축 요약
- 요약 목적에 따라 다양한 스타일 제공 (간단 개요 / 실행 보고 / 기술 문서 요약 등)

### 4. Generator
- 새로운 텍스트, 코드, 시나리오 생성
- 자연어 응답 / 코드 샘플 / 보고서 / 시뮬레이션 데이터 생성
- 주어진 규칙/포맷(JSON, Markdown 등)에 맞춰 출력

### 5. Evaluator / Critic
- 결과물의 품질 평가 (정확성, 일관성, 스타일, 포맷 적합성)
- 대안 제시, 개선 포인트 피드백
- Self-Check, Chain-of-Thought 기반 평가

### 6. Rewriter / Refiner
- 기존 결과물을 개선 (간결화, 가독성 향상, 문체 통일, 오류 수정)
- 특정 목적에 맞게 재작성 (보고용, 기술 문서용, 사용자 친화용 등)

### 7. Explainer / Tutor
- 특정 개념, 프로세스, 코드에 대해 단계별 설명
- 초보자/전문가 수준 맞춤형 설명
- Q&A 형식으로 학습 지원

### 8. Reasoner / Inference Engine
- 규칙/조건 기반 추론 (If-Then, 시나리오별 결과 예측)
- 불완전한 정보로부터 합리적 추론
- 논리적 일관성 점검

### 9. Converter / Translator
- 언어 번역 (다국어 자연어 변환)
- 포맷 변환 (평문 ↔ JSON ↔ Markdown 등)
- 코드 변환 (Python ↔ C#, SQL ↔ LINQ 등)

### 10. Visualizer (Text-based)
- 데이터/프로세스를 도표, 표, 그래프 형태로 설명
- PlantUML, Mermaid, Markdown 표 생성
- 차트, 시퀀스 다이어그램, 구조도 텍스트 기반 생성

### 11. Tool Parameter Setter
- 외부 TOOL 호출에 필요한 파라미터 값 구성
- 입력값 보정, 기본값 채우기, 누락 항목 유추
- JSON Schema, OpenAPI, Manifest 기반 파라미터 자동 매핑

### 12. Dialogue Manager
- 사용자와 대화 흐름 관리
- 맥락 기억, 대화 단계 조정
- Clarification Question 생성 (필요한 추가 정보 요청)

### 13. Knowledge Retriever
- 외부 벡터DB, 문서 검색 API, 사내 데이터베이스에서 정보 조회
- 쿼리 재구성, 관련도 높은 결과 정리
- 검색 결과를 다음 Reasoning 단계로 전달

### 14. Meta-Manager
- 현재 LLM 응답의 신뢰도 추정 (확실 / 불확실)
- 어떤 역할(Planner, Generator, Evaluator 등)을 호출할지 결정
- 자기 출력에 대한 메타 분석(Self-Reflection)

## 추가 고려사항

### 임베딩 캐싱 전략
- 의미적으로 유사한 요청 감지
- 결과 재사용 가능성 판단
- TTL과 무효화 전략

### 스트리밍 응답
- 초기 개발은 일반 응답으로 처리
- 스트리밍 응답은 추후 검토 필요

### Fallback 전략
- LLM 응답 실패 시 대응 전략 수립 필요

### 확장성
- LLM 기능 추가는 TOOL만큼 유연하지 않지만 확장 가능하도록 초기부터 설계